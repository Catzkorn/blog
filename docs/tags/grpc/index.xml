<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Grpc on Go Ahead</title>
    <link>https://jbrandhorst.com/tags/grpc/</link>
    <description>Recent content in Grpc on Go Ahead</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 17 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jbrandhorst.com/tags/grpc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Client side streaming in gRPC-Web</title>
      <link>https://jbrandhorst.com/post/client-streaming/</link>
      <pubDate>Sun, 17 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/client-streaming/</guid>
      <description>In a previous post I introduced my open source project to bring GopherJS bindings to Improbable&amp;rsquo;s gRPC-Web client. I&amp;rsquo;m happy to say that the initial goal of supporting all features of the gRPC-Web client has been completed. I was initially going to leave it at that and wait for client side streaming to land in the WHATWG Streams API Standard, and subsequently added to the official grpc-web spec and probably the gRPC-Web client, but then I was sitting at the GolangUK conference and I had a brain wave.</description>
    </item>
    
    <item>
      <title>Chunking large messages with gRPC</title>
      <link>https://jbrandhorst.com/post/grpc-binary-blob-stream/</link>
      <pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/grpc-binary-blob-stream/</guid>
      <description>One of the gotchas of using gRPC is that it was not designed to transport large messages in one chunk. The default max message size is slightly arbitrarily set at 4MB today, and while it is possible to configure, that kind of behaviour might lead to a slippery slope scenario of ever increasing max message sizes. So what do we do when the message size is too large? We chunk the data into smaller pieces and stream it, using the gRPC streaming methods, naturally.</description>
    </item>
    
    <item>
      <title>Throttling resource intensive requests</title>
      <link>https://jbrandhorst.com/post/go-semaphore/</link>
      <pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/go-semaphore/</guid>
      <description>Sometimes when you&amp;rsquo;re writing a server, you&amp;rsquo;ve got a function that consumes a lot of memory while running, or some other resource, and you might be worrying that a sudden burst of requests could crash the server, since gRPC by default will just spawn another goroutine to handle any incoming requests, oblivious to the danger. In these situations, it can be useful to implement some custom request throttling. Here I&amp;rsquo;ll show an easy way to accomplish this with the use of a Go channel.</description>
    </item>
    
    <item>
      <title>gRPC-Web with GopherJS</title>
      <link>https://jbrandhorst.com/post/gopherjs-grpcweb/</link>
      <pubDate>Tue, 20 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-grpcweb/</guid>
      <description>In a previous blog series I&amp;rsquo;ve talked about how to work with a gRPC backend from the GopherJS world. It relies on the gRPC-gateway which is a great piece of tech, but unfortunately carries a couple of downsides:
 Clients don&amp;rsquo;t know what types are used - the interface is HTTP JSON. This can be somewhat mitigated with the use of swagger generated interfaces, but it&amp;rsquo;s still not perfect. The interface being JSON means marshalling and unmarshalling can become a significant part of the latency between the client and the server.</description>
    </item>
    
    <item>
      <title>Go Protobuf Tips</title>
      <link>https://jbrandhorst.com/post/go-protobuf-tips/</link>
      <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/go-protobuf-tips/</guid>
      <description>I&amp;rsquo;ve had my fair share of dealing with proto files in go (and to some extent JS), so I thought I&amp;rsquo;d share some stuff I&amp;rsquo;ve learnt the hard way by working with proto files.
Protoc include paths The protoc include paths can be pretty confusing, so I&amp;rsquo;ll give a few examples of how to use it properly.
Just include the current directory protoc requires that the files referenced are in the include path, so if you&amp;rsquo;re referencing files relative to the current directory, you&amp;rsquo;ll need to specify -I.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 4</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/</link>
      <pubDate>Fri, 14 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/</guid>
      <description>Putting it all together As we touched upon earlier, we generate a package from the generated JS (meta, right?), which can be served from the server. We&amp;rsquo;ll create a new file, main.go, in which we can spin up a server, serve the frontend and the gRPC backend.
Much of the logic in this file is inspired by the excellent blog post put together by Brandon Philips over at CoreOS. We&amp;rsquo;re using his elegant solution to serve both the HTTP API and the gRPC API on the same port.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 3</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/</link>
      <pubDate>Thu, 13 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/</guid>
      <description>Implement the client GopherJS can be used in a couple of different ways, and there&amp;rsquo;s a couple of different bindings to many popular JavaScript frameworks. The GopherJS wiki has some great resources.
I tried a couple of different ones and ended up using the VueJS bindings because it made it easy to prototype things quickly. I hear VueJS works well for many JS evangelisers out there, but I&amp;rsquo;ve only used it with small projects.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 2</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/</link>
      <pubDate>Wed, 12 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/</guid>
      <description>Implement the server I like to start by creating a struct and write a simple definition that&amp;rsquo;ll immediately fail to compile.
package server import ( &amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/protos/server&amp;quot; ) type Server struct{} var _ server.MyServerServer = &amp;amp;Server{}  This won&amp;rsquo;t compile, because the Server struct does not implement the server.MyServerServer interface. But it&amp;rsquo;ll also tell us what we&amp;rsquo;ve got left to implement. So lets implement the server methods:
func (s Server) Simple(ctx context.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 1</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/</link>
      <pubDate>Tue, 11 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/</guid>
      <description>Create the protobuf interface We&amp;rsquo;ll start by creating a folder for the package we want to create. Lets call it server. Next we type up a .proto file to define the interface between the server and the client. We&amp;rsquo;ll have to include some extra proto annotations in order to have the gRPC-gateway generate the translations methods we need. Lets define a simple service with a single HTTP GET endpoint:</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Introduction</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server/</link>
      <pubDate>Mon, 10 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server/</guid>
      <description>I&amp;rsquo;ve been using gRPC and Go a lot in the last year. At Cognitive Logic every one of our backend services is implemented with Go and gRPC, and it enables us to abstract away most of the complexities of networked micro services and keep interfaces typed and well defined using Google protobuffers.
I really enjoy using both, but sometimes I need to write a frontend to a web server and I despise writing Javascript.</description>
    </item>
    
  </channel>
</rss>