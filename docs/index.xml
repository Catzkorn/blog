<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go Ahead</title>
    <link>https://jbrandhorst.com/</link>
    <description>Recent content on Go Ahead</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 04 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jbrandhorst.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advanced CircleCI docker testing</title>
      <link>https://jbrandhorst.com/post/circleci-docker-compose/</link>
      <pubDate>Fri, 04 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/circleci-docker-compose/</guid>
      <description>In a recent blog post I talked about automating the testing of an advanced GopherJS library using a combination of QUnit, Ginkgo and Agouti. That allowed me to run a complete integration test suite against my library by automatically spinning up browsers and pointing them at my QUnit GopherJS page. This was a great start, but after running it a couple of times we find that there are several problems:</description>
    </item>
    
    <item>
      <title>Chunking large messages with gRPC</title>
      <link>https://jbrandhorst.com/post/grpc-binary-blob-stream/</link>
      <pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/grpc-binary-blob-stream/</guid>
      <description>One of the gotchas of using gRPC is that it was not designed to transport large messages in one chunk. The default max message size is slightly arbitrarily set at 4MB today, and while it is possible to configure, that kind of behaviour might lead to a slippery slope scenario of ever increasing max message sizes. So what do we do when the message size is too large? We chunk the data into smaller pieces and stream it, using the gRPC streaming methods, naturally.</description>
    </item>
    
    <item>
      <title>Throttling resource intensive requests</title>
      <link>https://jbrandhorst.com/post/go-semaphore/</link>
      <pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/go-semaphore/</guid>
      <description>Sometimes when you&amp;rsquo;re writing a server, you&amp;rsquo;ve got a function that consumes a lot of memory while running, or some other resource, and you might be worrying that a sudden burst of requests could crash the server, since gRPC by default will just spawn another goroutine to handle any incoming requests, oblivious to the danger. In these situations, it can be useful to implement some custom request throttling. Here I&amp;rsquo;ll show an easy way to accomplish this with the use of a Go channel.</description>
    </item>
    
    <item>
      <title>GopherJS Integration Tests</title>
      <link>https://jbrandhorst.com/post/gopherjs-integration-tests/</link>
      <pubDate>Tue, 11 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-integration-tests/</guid>
      <description>Recently I found myself wondering how I was going to test my new GopherJS gRPC-Web bindings. Writing tests was something I had been waiting with until I had something working, mostly because I had no idea how I was going to meaningfully test GopherJS code that relies on interactions with JS and the reponses of a server.
I have in the past made a small contribution to the GopherJS websocket repo, and found myself impressed with the extensive tests written for the repo.</description>
    </item>
    
    <item>
      <title>gRPC-Web with GopherJS</title>
      <link>https://jbrandhorst.com/post/gopherjs-grpcweb/</link>
      <pubDate>Tue, 20 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-grpcweb/</guid>
      <description>In a previous blog series I&amp;rsquo;ve talked about how to work with a gRPC backend from the GopherJS world. It relies on the gRPC-gateway which is a great piece of tech, but unfortunately carries a couple of downsides:
 Clients don&amp;rsquo;t know what types are used - the interface is HTTP JSON. This can be somewhat mitigated with the use of swagger generated interfaces, but it&amp;rsquo;s still not perfect. The interface being JSON means marshalling and unmarshalling can become a significant part of the latency between the client and the server.</description>
    </item>
    
    <item>
      <title>Auto-deployment of your app from Github</title>
      <link>https://jbrandhorst.com/post/app-deployment/</link>
      <pubDate>Sun, 04 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/app-deployment/</guid>
      <description>Introduction Yesterday (!) I asked in the Gophers slack for recommendations for deployment of static Go binaries, as I was in the process of deploying a demo for another blog post I&amp;rsquo;m working on. I was told to check out Scaleway among other things, and found it to be an excellent option for simple and cheap hosting. It currently provides data centres in Paris and Amsterdam, which is perfect for me.</description>
    </item>
    
    <item>
      <title>Go Protobuf Tips</title>
      <link>https://jbrandhorst.com/post/go-protobuf-tips/</link>
      <pubDate>Tue, 18 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/go-protobuf-tips/</guid>
      <description>I&amp;rsquo;ve had my fair share of dealing with proto files in go (and to some extent JS), so I thought I&amp;rsquo;d share some stuff I&amp;rsquo;ve learnt the hard way by working with proto files.
Protoc include paths The protoc include paths can be pretty confusing, so I&amp;rsquo;ll give a few examples of how to use it properly.
Just include the current directory protoc requires that the files referenced are in the include path, so if you&amp;rsquo;re referencing files relative to the current directory, you&amp;rsquo;ll need to specify -I.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 4</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/</link>
      <pubDate>Fri, 14 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/</guid>
      <description>Putting it all together As we touched upon earlier, we generate a package from the generated JS (meta, right?), which can be served from the server. We&amp;rsquo;ll create a new file, main.go, in which we can spin up a server, serve the frontend and the gRPC backend.
Much of the logic in this file is inspired by the excellent blog post put together by Brandon Philips over at CoreOS. We&amp;rsquo;re using his elegant solution to serve both the HTTP API and the gRPC API on the same port.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 3</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/</link>
      <pubDate>Thu, 13 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/</guid>
      <description>Implement the client GopherJS can be used in a couple of different ways, and there&amp;rsquo;s a couple of different bindings to many popular JavaScript frameworks. The GopherJS wiki has some great resources.
I tried a couple of different ones and ended up using the VueJS bindings because it made it easy to prototype things quickly. I hear VueJS works well for many JS evangelisers out there, but I&amp;rsquo;ve only used it with small projects.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 2</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/</link>
      <pubDate>Wed, 12 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/</guid>
      <description>Implement the server I like to start by creating a struct and write a simple definition that&amp;rsquo;ll immediately fail to compile.
package server import ( &amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/protos/server&amp;quot; ) type Server struct{} var _ server.MyServerServer = &amp;amp;Server{}  This won&amp;rsquo;t compile, because the Server struct does not implement the server.MyServerServer interface. But it&amp;rsquo;ll also tell us what we&amp;rsquo;ve got left to implement. So lets implement the server methods:
func (s Server) Simple(ctx context.</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 1</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/</link>
      <pubDate>Tue, 11 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/</guid>
      <description>Create the protobuf interface We&amp;rsquo;ll start by creating a folder for the package we want to create. Lets call it server. Next we type up a .proto file to define the interface between the server and the client. We&amp;rsquo;ll have to include some extra proto annotations in order to have the gRPC-gateway generate the translations methods we need. Lets define a simple service with a single HTTP GET endpoint:</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Introduction</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server/</link>
      <pubDate>Mon, 10 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server/</guid>
      <description>I&amp;rsquo;ve been using gRPC and Go a lot in the last year. At Cognitive Logic every one of our backend services is implemented with Go and gRPC, and it enables us to abstract away most of the complexities of networked micro services and keep interfaces typed and well defined using Google protobuffers.
I really enjoy using both, but sometimes I need to write a frontend to a web server and I despise writing Javascript.</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://jbrandhorst.com/page/about/</link>
      <pubDate>Thu, 23 Mar 2017 22:25:56 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/page/about/</guid>
      <description>I&amp;rsquo;m Johan, I like gaming, programming, floorball, skiing and many other things. I&amp;rsquo;m originally from Sweden but I live and work in the United Kingdom. I work at InfoSum, a data startup in Basingstoke, UK.
My (current!) favourite programming languages are Go and Python. I also have a great interest in learning Rust and Elm.
You can find me on the Gophers Slack under the id jbrandhorst, where I like to hang around and discuss Go with fellow Gophers.</description>
    </item>
    
  </channel>
</rss>